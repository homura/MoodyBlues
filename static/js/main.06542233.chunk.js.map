{"version":3,"sources":["App.tsx","container/Header.tsx","component/SVGTooltip.tsx","component/Heatmap.tsx","container/RoundHeatmap.tsx","helper.ts","container/EventDetail.tsx","container/EventList.tsx","container/EpochOverview.tsx","component/Hex.tsx","container/Dashboard.tsx","container/Timeline.tsx","container/EpochTimeline.tsx","container/Profile.tsx","mock.ts","component/FileZone/index.tsx","container/Guide.tsx","store/index.ts","types.ts","serviceWorker.ts","index.tsx","event.ts","constants.ts"],"names":["Content","hot","module","store","Header","Logo","styled","div","AppHeader","type","SVGTooltip","props","followCursor","plugins","HeatmapWrapper","svg","undefined","activeIndex","LegendItemWrapper","span","LegendItem","fill","label","width","height","x","y","Heatmap","withSize","padding","size","data","columnCount","Math","floor","scale","scaleLinear","domain","range","useState","tooltipContent","setTooltipContent","cells","useMemo","map","item","i","key","interpolateGreens","onMouseOver","onTooltip","onClick","onCellClick","active","animation","content","RoundHeatmap","useStoreState","state","tracer","events","activeEpoch","activateEpoch","useStoreActions","actions","epochRoundMap","Events","roundCountEachEpoch","Array","from","keys","values","epochIds","roundIds","indexOf","wrap0x","toHex","input","startsWith","toString","formatDate","date","pattern","format","theme","scheme","base00","base01","base02","base03","base04","base05","base06","base07","base08","base09","base0A","base0B","base0C","base0D","base0E","base0F","EventDetail","event","tag","_","get","eventName","timestamp","invertTheme","hideRoot","EventName","EventList","slice","activeEvent","activateEvent","inactivateEvent","epoch","epochEvents","columns","title","dataIndex","render","name","record","index","startIndex","style","position","overflow","pagination","rowKey","String","dataSource","scroll","placement","onClose","visible","mask","getContainer","EpochOverview","epochSlice","roundCount","rounds","length","timeUsage","gutter","value","copyTextToClipboard","text","navigator","clipboard","writeText","textArea","document","createElement","body","appendChild","focus","select","execCommand","err","console","error","removeChild","fallbackCopyTextToClipboard","Promise","resolve","HexContainer","Hex","short","shortHex","hex","overlay","then","message","info","DashboardWrapper","ProposeTable","VoteTable","Dashboard","activeRound","filter","isNil","epochId","roundId","md","sm","filterProposeEvents","filterVoteEvents","hoveringSegmentBackground","color","brighter","activeSegmentBackground","TimelineWrapper","Timeline","head","segments","last","start","total","xScale","widthScale","className","classNames","segment","segmentsText","onTip","tip","left","handleActive","EpochTimeline","roundSlice","activateRound","activateStep","inactivateRound","inactivateStep","activeRoundIndex","setActiveRoundIndex","activeStepIndex","setActiveStepIndex","handleInactiveStep","useEffect","roundTimelineProps","round","timeRange","handleActiveRound","stepTimelineProps","steps","step","stepName","handleActiveStep","ProfileWrapper","Profile","epochSelected","randomBytesAsHex","randombytes","randomAddress","mockStartRound","keyframe","Keyframe","START_ROUND","mockStartStep","START_STEP","ns","vn","flatMap","v","n","ts","address","lock","random","tx","proposal","mockCustomEvent","rand","eventType","EventType","Propose","proposer","hash","mockReceivePropose","Vote","sample","voter","mockReceiveVote","Mock","options","time","this","initialOptions","startTime","startEpochId","Object","assign","epochCount","Date","now","max","consumeTime","push","count","START_EPOCH","baseStyle","flex","display","flexDirection","alignItems","borderWidth","borderRadius","borderColor","borderStyle","outline","transition","activeStyle","acceptStyle","rejectStyle","JSONLogReader","onLoad","useDropzone","accept","multiple","getRootProps","getInputProps","isDragActive","isDragAccept","isDragReject","acceptedFiles","file","isEmpty","reject","reader","FileReader","onload","result","JSON","parse","readAsText","example","mock","blob","Blob","stringify","saveAs","saveFile","Guide","eventLoaded","loadEvents","storeModel","activeStep","computed","log","action","inactivateEpoch","typedHooks","createTypedHooks","createStore","useStoreDispatch","Boolean","window","location","hostname","match","ReactDOM","App","getElementById","serviceWorker","ready","registration","unregister","indexOfKeyframe","findIndex","isKeyframe","isKeyframeStartsOfEpoch","isKeyframeStartsOfRound","isKeyframeStartsOfStep","indexOfNextKeyframe","isProposeEvent","isVoteEvent","indexOfNextKeyframeByKey","checkIsKeyframeOf","BaseEvents","raw","endIndex","parent","memoize","nextSliceStartEvent","nextKeyframe","startAt","endAt","sliceArgs","end","EpochEvents","self","RoundEvents","roundEvents","StepEvents","parentSlice","nextRoundIndex","offset","empty","parentEvents","nextStepIndex","Map","newEpoch","set","forEach","e","EventScopeType"],"mappings":"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","file":"static/js/main.06542233.chunk.js","sourcesContent":["import React from 'react';\nimport { hot } from 'react-hot-loader';\nimport './App.css';\nimport { store } from './store';\nimport { StoreProvider } from 'easy-peasy';\nimport { Layout } from 'antd';\nimport { AppHeader } from './container/Header';\nimport { Guide } from './container/Guide';\n\nconst { Content } = Layout;\n\nconst App: React.FC = () => {\n  return (\n    <StoreProvider store={store}>\n      <AppHeader />\n      <Content>\n        <Guide />\n      </Content>\n    </StoreProvider>\n  );\n};\n\nexport default hot(module)(App);\n","import React from 'react';\nimport { Icon, Layout } from 'antd';\nimport styled from 'styled-components';\n\nconst Header = Layout.Header;\n\nconst Logo = styled.div`\n  width: 120px;\n  height: 31px;\n  margin: 16px 24px 16px 0;\n  line-height: 32px;\n  float: left;\n  font-weight: bold;\n`;\n\nexport const AppHeader: React.FC = () => {\n  return (\n    <Header>\n      <Logo>\n        <Icon type=\"play-circle\" /> Moody Blues\n      </Logo>\n    </Header>\n  );\n};\n","import React from 'react';\nimport Tippy, { TippyProps } from '@tippy.js/react';\nimport { followCursor } from 'tippy.js';\nimport 'tippy.js/dist/tippy.css';\n\nexport const SVGTooltip = (props: TippyProps) => {\n  return <Tippy followCursor={true} plugins={[followCursor]} {...props} />;\n};\n","import React, { ReactChild, useMemo, useState } from 'react';\nimport { interpolateGreens } from 'd3-scale-chromatic';\nimport { scaleLinear } from 'd3-scale';\nimport { SizeMeProps, withSize } from 'react-sizeme';\nimport styled from 'styled-components';\nimport { SVGTooltip } from './SVGTooltip';\n\ninterface HeatmapWrapperProps {\n  readonly activeIndex?: number;\n}\n\nconst HeatmapWrapper = styled.svg<HeatmapWrapperProps>`\n  rect {\n    opacity: ${props => (props.activeIndex !== undefined ? 0.25 : 1)};\n  }\n\n  rect:nth-child(${props =>\n        'activeIndex' in props ? (props.activeIndex as number) + 1 : 0}) {\n    opacity: 1;\n    stroke: #0e639c;\n  }\n`;\n\nconst LegendItemWrapper = styled.span`\n  margin-right: 8px;\n\n  svg {\n    vertical-align: middle;\n  }\n`;\n\nconst LegendItem = ({ fill, label }: { fill: string; label: string }) => {\n  return (\n    <LegendItemWrapper>\n      <svg width={15} height={15}>\n        <rect x={0} y={0} width={12} height={12} fill={fill} />\n      </svg>\n      <span>{label}</span>\n    </LegendItemWrapper>\n  );\n};\n\nexport type HeatmapProps = SizeMeProps & {\n  data: number[];\n  domain: number[];\n  range: number[];\n  active?: number;\n  onTooltip?: (index: number) => ReactChild;\n  onCellClick?: (index: number) => void;\n};\n\nexport const Heatmap = withSize()((props: HeatmapProps) => {\n  const padding = [0, 0];\n  const width = (props.size.width as number) - padding[1] * 2;\n  const height = 200 - padding[0] * 2;\n\n  const { data } = props;\n\n  const cellSize = 12;\n  const paddedCellSize = 15;\n  const columnCount = Math.floor(height / paddedCellSize);\n\n  const scale = scaleLinear()\n    .domain([0, 3, 5])\n    .range([0, 0.8, 1]);\n\n  const [tooltipContent, setTooltipContent] = useState<ReactChild | undefined>(\n    '',\n  );\n\n  const cells = useMemo(\n    () => (\n      <g>\n        {data.map((item, i) => {\n          return (\n            <rect\n              key={i}\n              x={paddedCellSize * Math.floor(i / columnCount)}\n              y={paddedCellSize * (i % columnCount)}\n              width={cellSize}\n              height={cellSize}\n              fill={item === -1 ? '#ebedf0' : interpolateGreens(scale(item))}\n              onMouseOver={() => setTooltipContent(props.onTooltip?.(i))}\n              onClick={() => props.onCellClick?.(i)}\n            />\n          );\n        })}\n      </g>\n    ),\n    [data],\n  );\n\n  return (\n    <div>\n      <HeatmapWrapper width={width} height={height} activeIndex={props.active}>\n        <SVGTooltip animation=\"fade\" content={tooltipContent as ReactChild}>\n          {cells}\n        </SVGTooltip>\n      </HeatmapWrapper>\n      <div>\n        <LegendItem fill=\"#ebedf0\" label=\"incomplete\" />\n        <LegendItem fill={interpolateGreens(scale(1))} label=\"1\" />\n        <LegendItem fill={interpolateGreens(scale(3))} label=\"3\" />\n        <LegendItem fill={interpolateGreens(scale(5))} label=\"≥ 5\" />\n      </div>\n    </div>\n  );\n});\n","import React, { useMemo } from 'react';\nimport { Heatmap } from '../component/Heatmap';\nimport { Events } from '../event';\nimport { useStoreActions, useStoreState } from '../store';\n\nexport const RoundHeatmap = () => {\n  const { events, activeEpoch } = useStoreState(state => state.tracer);\n  const activateEpoch = useStoreActions(\n    actions => actions.tracer.activateEpoch,\n  );\n\n  const epochRoundMap = useMemo(() => {\n    return new Events(events).roundCountEachEpoch();\n  }, [events]);\n\n  const [epochIds, roundIds] = useMemo((): [number[], number[]] => {\n    const epochIds = Array.from(epochRoundMap.keys());\n    const roundIds = Array.from(epochRoundMap.values());\n    return [epochIds, roundIds];\n  }, [epochRoundMap]);\n\n  const activeIndex = useMemo(() => {\n    if (activeEpoch === null) return undefined;\n    return epochIds.indexOf(activeEpoch);\n  }, [epochIds, activeEpoch]);\n\n  return (\n    <Heatmap\n      domain={[0, 3, 5]}\n      range={[0, 0.8, 1]}\n      data={roundIds}\n      active={activeIndex}\n      onCellClick={i => activateEpoch(epochIds[i])}\n      onTooltip={i => (\n        <div>\n          epoch: {epochIds[i]} <br /> round: {roundIds[i]}\n        </div>\n      )}\n    />\n  );\n};\n","import { format } from 'date-fns';\nimport { TraceEvent } from './types';\n\nfunction wrap0x(x: string): string {\n  return `0x${x}`;\n}\n\nexport function toHex(input: string | number): string {\n  if (typeof input === 'string') {\n    if (input.startsWith('0x')) return input;\n    return wrap0x(input);\n  }\n  return wrap0x(input.toString(16));\n}\n\nexport function shortHex(input: string | number): string {\n  return toHex(input).slice(0, 8);\n}\n\nfunction hashCode(str: string) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash = str.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  return hash;\n}\n\nfunction intToRGB(i: number) {\n  const c = (i & 0x00ffffff).toString(16).toUpperCase();\n  return '00000'.substring(0, 6 - c.length) + c;\n}\n\nexport function anyStrToColor(str: string): string {\n  return '#' + intToRGB(hashCode(str));\n}\n\nexport function readJSONLog(file: File): Promise<TraceEvent[]> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const events = reader.result as string;\n      resolve(JSON.parse(events));\n    };\n    reader.readAsText(file);\n  });\n}\n\nexport function formatDate(date: Date | number, pattern?: string) {\n  pattern = pattern ?? 'yyyy-MM-dd HH:mm:ss:SSS';\n  return format(date, pattern);\n}\n","import React from 'react';\nimport { Divider, Row, Col } from 'antd';\nimport JSONTree from 'react-json-tree';\nimport _ from 'lodash';\nimport { TraceEvent } from '../types';\nimport { formatDate } from '../helper';\n\nconst theme = {\n  scheme: 'monokai',\n  base00: 'unset',\n  base01: '#383830',\n  base02: '#49483e',\n  base03: '#75715e',\n  base04: '#a59f85',\n  base05: '#f8f8f2',\n  base06: '#f5f4f1',\n  base07: '#f9f8f5',\n  base08: '#f92672',\n  base09: '#fd971f',\n  base0A: '#f4bf75',\n  base0B: '#a6e22e',\n  base0C: '#a1efe4',\n  base0D: '#66d9ef',\n  base0E: '#ae81ff',\n  base0F: '#cc6633',\n};\n\ninterface EventDetailProps {\n  event: TraceEvent;\n}\n\nexport const EventDetail = (props: EventDetailProps) => {\n  const { event } = props;\n  if (!event) return null;\n\n  const tag = { tag: _.get(event, 'tag') } as {};\n\n  return (\n    <div>\n      <Row>\n        <Col span={8}>name</Col>\n        <Col span={16}>{event.eventName}</Col>\n\n        <Col span={8}>time</Col>\n        <Col span={16}>{formatDate(event.timestamp)}</Col>\n      </Row>\n      <Divider />\n      <JSONTree data={tag} theme={theme} invertTheme={false} hideRoot={true} />\n    </div>\n  );\n};\n","import React from 'react';\nimport { Drawer, Table } from 'antd';\nimport styled from 'styled-components';\nimport { useStoreActions, useStoreState } from '../store';\nimport { TraceEvent } from '../types';\nimport { EventDetail } from './EventDetail';\nimport { formatDate } from '../helper';\n\nconst EventName = styled.div`\n  cursor: pointer;\n`;\n\ninterface EventListProp {}\n\nexport const EventList = (props: EventListProp) => {\n  const { slice, activeEpoch, activeEvent } = useStoreState(\n    state => state.tracer,\n  );\n  const { activateEvent, inactivateEvent } = useStoreActions(\n    actions => actions.tracer,\n  );\n  if (activeEpoch === null) return null;\n  const epoch = slice.epoch(activeEpoch);\n  const epochEvents = epoch.events();\n\n  const columns = [\n    {\n      key: 'Name',\n      title: 'Name',\n      dataIndex: 'eventName',\n      render: (name: string, record: TraceEvent, index: number) => (\n        <EventName onClick={() => activateEvent(index + epoch.startIndex)}>\n          {name}\n        </EventName>\n      ),\n    },\n    {\n      key: 'Timestamp',\n      title: 'Timestamp',\n      dataIndex: 'timestamp',\n      render: (timestamp: number) => formatDate(timestamp),\n    },\n  ];\n\n  return (\n    <div style={{ position: 'relative', overflow: 'hidden' }}>\n      <Table\n        size=\"small\"\n        pagination={false}\n        rowKey={(record: TraceEvent, i) => String(i)}\n        dataSource={epochEvents}\n        columns={columns}\n        scroll={{ y: 300 }}\n      />\n\n      <Drawer\n        placement=\"right\"\n        width={400}\n        onClose={() => inactivateEvent()}\n        visible={!!activeEvent}\n        mask={false}\n        getContainer={false}\n        style={{ position: 'absolute' }}\n      >\n        <EventDetail event={activeEvent as TraceEvent} />\n      </Drawer>\n    </div>\n  );\n};\n","import React from 'react';\nimport { Row, Col, Statistic } from 'antd';\nimport { useStoreState } from '../store';\n\ninterface EpochOverviewProps {}\n\nexport const EpochOverview = (props: EpochOverviewProps) => {\n  const { activeEpoch, epochSlice } = useStoreState(state => state.tracer);\n\n  if (activeEpoch === null) return null;\n\n  const roundCount: number = epochSlice.rounds().length;\n  const timeUsage: string = epochSlice.timeUsage() + 'ms';\n\n  return (\n    <Row gutter={16}>\n      <Col span={6}>\n        <Statistic title=\"Epoch\" value={activeEpoch} />\n      </Col>\n      <Col span={6}>\n        <Statistic title=\"Round usage\" value={roundCount} />\n      </Col>\n\n      <Col span={6}>\n        <Statistic title=\"Time usage\" value={timeUsage} />\n      </Col>\n    </Row>\n  );\n};\n","import React from 'react';\nimport styled from 'styled-components';\n\nimport { Tooltip, message } from 'antd';\nimport { shortHex, toHex } from '../helper';\n\nfunction fallbackCopyTextToClipboard(text: string) {\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n  textArea.style.position = 'fixed'; //avoid scrolling to bottom\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    document.execCommand('copy');\n  } catch (err) {\n    console.error('Fallback: Oops, unable to copy', err);\n  }\n\n  document.body.removeChild(textArea);\n}\nfunction copyTextToClipboard(text: string): Promise<void> {\n  if (!navigator.clipboard) {\n    fallbackCopyTextToClipboard(text);\n    return Promise.resolve();\n  }\n  return navigator.clipboard.writeText(text);\n}\n\nfunction copyToClipboard(text: string) {\n  copyTextToClipboard(text).then(() => {\n    message.info('copied', 1);\n  });\n}\n\nconst HexContainer = styled.span`\n  cursor: pointer;\n  display: inline-block;\n`;\n\ninterface HexProps {\n  data: string | number;\n  short?: boolean;\n}\n\nexport const Hex = (props: HexProps) => {\n  const input = props.data;\n  const short = shortHex(input);\n  const hex = toHex(input);\n\n  return (\n    <Tooltip overlay={hex}>\n      <HexContainer onClick={() => copyToClipboard(hex)}>{short}</HexContainer>\n    </Tooltip>\n  );\n};\n","import React from 'react';\nimport { Card, Row, Col, Table } from 'antd';\nimport styled from 'styled-components';\nimport { useStoreState } from '../store';\nimport { filterProposeEvents, filterVoteEvents } from '../event';\nimport _ from 'lodash';\nimport { ProposeEvent, VoteEvent } from '../types';\nimport { ColumnProps } from 'antd/es/table';\nimport { Hex } from '../component/Hex';\n\nfunction shortHex(hex: string) {\n  return <Hex data={hex} />;\n}\n\nconst DashboardWrapper = styled.div`\n  padding: 16px 0;\n`;\n\nfunction ProposeTable(props: { events: ProposeEvent[] }) {\n  const columns: ColumnProps<ProposeEvent>[] = [\n    { title: 'Name', key: 'eventName', dataIndex: 'eventName' },\n    { title: 'Round', key: 'tag.roundId', dataIndex: 'tag.roundId' },\n    {\n      title: 'Proposer',\n      key: 'tag.proposer',\n      dataIndex: 'tag.proposer',\n      render: shortHex,\n    },\n    {\n      title: 'Hash',\n      key: 'tag.hash',\n      dataIndex: 'tag.hash',\n      render: shortHex,\n    },\n  ];\n  return (\n    <Table\n      size=\"small\"\n      pagination={false}\n      scroll={{ y: 180 }}\n      columns={columns}\n      dataSource={props.events}\n    />\n  );\n}\n\nfunction VoteTable(props: { events: VoteEvent[] }) {\n  const columns: ColumnProps<VoteEvent>[] = [\n    { title: 'Name', key: 'eventName', dataIndex: 'eventName' },\n    { title: 'Round', key: 'tag.roundId', dataIndex: 'tag.roundId' },\n    {\n      title: 'Voter',\n      key: 'tag.voter',\n      dataIndex: 'tag.voter',\n      render: shortHex,\n    },\n    {\n      title: 'Hash',\n      key: 'tag.hash',\n      dataIndex: 'tag.hash',\n      render: shortHex,\n    },\n  ];\n  return (\n    <Table\n      size=\"small\"\n      pagination={false}\n      scroll={{ y: 180 }}\n      columns={columns}\n      dataSource={props.events}\n    />\n  );\n}\n\nexport const Dashboard = () => {\n  const { activeEpoch, activeRound, events } = useStoreState(\n    state => state.tracer,\n  );\n\n  const filter = _.isNil(activeEpoch)\n    ? {}\n    : _.isNil(activeRound)\n    ? { epochId: activeEpoch }\n    : { epochId: activeEpoch, roundId: activeRound };\n\n  return (\n    <DashboardWrapper>\n      <Row gutter={16}>\n        <Col md={12} sm={24}>\n          <Card title=\"Received proposal\">\n            <ProposeTable events={filterProposeEvents(events, filter)} />\n          </Card>\n        </Col>\n        <Col md={12} sm={24}>\n          <Card title=\"Received vote\">\n            <VoteTable events={filterVoteEvents(events, filter)} />\n          </Card>\n        </Col>\n      </Row>\n    </DashboardWrapper>\n  );\n};\n","import React, { ReactNode } from 'react';\nimport { withSize, SizeMeProps } from 'react-sizeme';\nimport { scaleLinear } from 'd3-scale';\nimport styled from 'styled-components';\nimport { color } from 'd3-color';\nimport _ from 'lodash';\nimport classNames from 'classnames';\nimport { Tooltip } from 'antd';\n\ntype Range = [number, number];\n\nexport type TimelineProps = {\n  activeIndex?: number;\n  segments: Range[];\n  segmentsText: string[];\n  domain?: Range;\n  onTip?: (i: number) => ReactNode;\n  onClick?: (i: number) => void;\n};\n\nconst segmentBackground = '#eec360';\nconst hoveringSegmentBackground = color(segmentBackground)\n  ?.brighter(1.2)\n  .hex() as string;\n\nconst activeSegmentBackground = color(segmentBackground)\n  ?.brighter(1.6)\n  .hex() as string;\n\nconst TimelineWrapper = styled.div`\n  white-space: nowrap;\n  position: relative;\n  height: 18px;\n\n  .segment {\n    position: absolute;\n    line-height: 18px;\n    font-size: 12px;\n    height: 18px;\n    display: inline-block;\n    border: 1px solid #333333;\n    border-right: none;\n    background-color: ${segmentBackground};\n    color: #333333;\n    text-align: center;\n    cursor: pointer;\n    transition: border 0.2s;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n\n    &:hover {\n      background-color: ${hoveringSegmentBackground};\n    }\n\n    &.active {\n      border: 2px solid #0e639c;\n      background-color: ${activeSegmentBackground};\n    }\n  }\n`;\n\nexport const Timeline = withSize()((props: TimelineProps & SizeMeProps) => {\n  const active = props.activeIndex;\n\n  const domain = props.domain || [\n    _.head(props.segments)?.[0] ?? 0,\n    _.last(props.segments)?.[1] ?? 0,\n  ];\n\n  const [start, end] = domain;\n  const total = end - start;\n  const width = props.size.width as number;\n\n  const xScale = scaleLinear()\n    .range([0, width])\n    .domain(domain);\n  const widthScale = scaleLinear()\n    .range([0, width])\n    .domain([0, total]);\n\n  function handleActive(i: number) {\n    // eslint-disable-next-line no-unused-expressions\n    props.onClick?.(i);\n  }\n\n  function tip(i: number): ReactNode {\n    return (\n      <div>\n        <div>{props.segmentsText[i]}</div>\n        {props.onTip && props.onTip(i)}\n      </div>\n    );\n  }\n\n  return (\n    <TimelineWrapper className={classNames({ active: !_.isNil(active) })}>\n      {props.segments.map((segment, i) => (\n        <Tooltip key={i} overlay={() => tip(i)}>\n          <div\n            className={classNames(['segment', { active: active === i }])}\n            style={{\n              width: `${widthScale(segment[1] - segment[0])}px`,\n              left: `${xScale(segment[0])}px`,\n            }}\n            onClick={() => handleActive(i)}\n          >\n            {props.segmentsText[i]}\n          </div>\n        </Tooltip>\n      ))}\n    </TimelineWrapper>\n  );\n});\n","import React, { useEffect, useMemo, useState } from 'react';\nimport { withSize, SizeMeProps } from 'react-sizeme';\nimport { useStoreActions, useStoreState } from '../store';\nimport { Timeline, TimelineProps } from './Timeline';\nimport { RoundSlice, StepSlice } from '../event';\n\ntype EpochTimelineProps = SizeMeProps & {};\n\nexport const EpochTimeline = withSize()((props: EpochTimelineProps) => {\n  const { epochSlice, roundSlice, activeEpoch, activeRound } = useStoreState(\n    state => state.tracer,\n  );\n  const {\n    activateRound,\n    activateStep,\n    inactivateRound,\n    inactivateStep,\n  } = useStoreActions(actions => actions.tracer);\n\n  const [activeRoundIndex, setActiveRoundIndex] = useState<\n    number | undefined\n  >();\n  const [activeStepIndex, setActiveStepIndex] = useState<number | undefined>();\n\n  useEffect(() => {\n    handleInactiveRound();\n  }, [activeEpoch]);\n\n  function handleActiveRound(i: number, rounds: RoundSlice[]) {\n    activateRound(rounds[i].roundId);\n    setActiveRoundIndex(i);\n    handleInactiveStep();\n  }\n\n  function handleActiveStep(i: number, steps: StepSlice[]) {\n    activateStep(steps[i].stepName);\n    setActiveStepIndex(i);\n  }\n\n  function handleInactiveRound() {\n    handleInactiveStep();\n    inactivateRound();\n    setActiveRoundIndex(undefined);\n  }\n\n  function handleInactiveStep() {\n    inactivateStep();\n    setActiveStepIndex(undefined);\n  }\n\n  const roundTimelineProps = useMemo<TimelineProps>(() => {\n    const rounds = epochSlice.rounds();\n    const segments = rounds.map(round => round.timeRange());\n    const segmentsText = rounds.map(round => `R${round.roundId}`);\n\n    return {\n      segments,\n      segmentsText,\n      onTip: i => rounds[i].timeUsage() + 'ms',\n      onClick: i => handleActiveRound(i, rounds),\n    };\n  }, [epochSlice]);\n\n  const stepTimelineProps = useMemo<TimelineProps>(() => {\n    const steps = roundSlice.steps();\n    const segments = steps.map(step => step.timeRange());\n    const segmentsText = steps.map(step => step.stepName);\n    return {\n      segments,\n      segmentsText,\n      onTip: i => steps[i].timeUsage() + 'ms',\n      onClick: i => handleActiveStep(i, steps),\n    };\n  }, [roundSlice]);\n\n  return (\n    <>\n      {activeEpoch !== null && (\n        <Timeline {...roundTimelineProps} activeIndex={activeRoundIndex} />\n      )}\n\n      {activeRound !== null && (\n        <Timeline {...stepTimelineProps} activeIndex={activeStepIndex} />\n      )}\n    </>\n  );\n});\n","import React from 'react';\nimport styled from 'styled-components';\nimport { Divider } from 'antd';\n\nimport { RoundHeatmap } from './RoundHeatmap';\nimport { EventList } from './EventList';\nimport { EpochOverview } from './EpochOverview';\nimport { Dashboard } from './Dashboard';\nimport { EpochTimeline } from './EpochTimeline';\nimport { useStoreState } from '../store';\nimport _ from 'lodash';\n\nconst ProfileWrapper = styled.div`\n  padding: 20px;\n`;\n\nexport const Profile: React.FC = () => {\n  const { activeEpoch } = useStoreState(state => state.tracer);\n\n  const epochSelected = !_.isNil(activeEpoch);\n\n  return (\n    <ProfileWrapper>\n      <RoundHeatmap />\n\n      {epochSelected && (\n        <>\n          <Divider />\n          <EpochOverview />\n\n          <Divider />\n          <EpochTimeline />\n          <Dashboard />\n\n          <Divider />\n          <EventList />\n        </>\n      )}\n    </ProfileWrapper>\n  );\n};\n","import _ from 'lodash';\nimport { Optional } from 'utility-types';\nimport randombytes from 'randombytes';\nimport {\n  EpochKeyframe,\n  Keyframe,\n  ProposeEvent,\n  RoundKeyframe,\n  StepKeyframe,\n  Tag,\n  TraceEvent,\n  VoteEvent,\n} from './types';\nimport { EventType } from './constants';\n\nfunction randomBytesAsHex(size: number = 32): string {\n  return '0x' + randombytes(size).toString('hex');\n}\n\nfunction randomAddress() {\n  return '0x10' + randombytes(20).toString('hex');\n}\n\nexport function mockStartEpoch(\n  timestamp: number,\n  epochId: number,\n): EpochKeyframe {\n  return {\n    timestamp,\n    eventName: 'goto_new_epoch',\n    keyframe: Keyframe.START_EPOCH,\n    tag: { epochId },\n  };\n}\n\nexport function mockStartRound(\n  timestamp: number,\n  roundId: number,\n): RoundKeyframe {\n  return {\n    timestamp,\n    eventName: 'goto_new_round',\n    keyframe: Keyframe.START_ROUND,\n    tag: { roundId },\n  };\n}\n\nconst steps = ['propose', 'prevote', 'precommit', 'commit'];\nexport function mockStartStep(timestamp: number, step: number): StepKeyframe {\n  const stepName = steps[step];\n  return {\n    eventName: stepName,\n    timestamp,\n    keyframe: Keyframe.START_STEP,\n    tag: { stepName },\n  };\n}\n\nexport function mockReceivePropose(\n  timestamp: number,\n  epochId: number,\n  roundId: number,\n): ProposeEvent {\n  return {\n    timestamp,\n    eventType: EventType.Propose,\n    eventName: 'receive_propose',\n    tag: {\n      epochId,\n      roundId,\n      proposer: randomAddress(),\n      hash: randomBytesAsHex(),\n    },\n  };\n}\n\nexport function mockReceiveVote(\n  timestamp: number,\n  epochId: number,\n  roundId: number,\n): VoteEvent {\n  return {\n    timestamp,\n    eventType: EventType.Vote,\n    eventName: _.sample(steps) as string,\n    tag: {\n      epochId,\n      roundId,\n      voter: randomAddress(),\n      hash: randomBytesAsHex(),\n    },\n  };\n}\n\nconst vs: string[] = [\n  'check',\n  'get',\n  'receive',\n  'request',\n  'start',\n  'validate',\n];\nconst ns: string[] = ['epoch', 'tx', 'proposal', 'vote', 'lock'];\nconst vn: string[] = _.flatMap(vs, v => ns.map(n => `${v}_${n}`));\n\nconst ts: Tag[] = [\n  { address: '0x10000000000000000000000000000000000000' },\n  {\n    address: '0x10000000000000000000000000000000000000',\n    lock: '0x10000000000000000000000000000000000000',\n  },\n  {\n    key: Math.random(),\n  },\n  {\n    tx: '0x10000000000000000000000000000000000000',\n    proposal: '0x10000000000000000000000000000000000000',\n  },\n];\n\nfunction mockTag(): Tag | undefined {\n  return _.sample(ts);\n}\n\nexport function mockCustomEvent(\n  timestamp: number,\n  epochId: number,\n  roundId: number,\n): TraceEvent {\n  const rand = Math.random();\n  if (rand < 0.33) {\n    return mockReceivePropose(timestamp, epochId, roundId);\n  } else if (rand < 0.66) {\n    return mockReceiveVote(timestamp, epochId, roundId);\n  }\n  return {\n    timestamp,\n    eventName: _.sample(vn) as string,\n    tag: mockTag(),\n  };\n}\n\ninterface MockOptions {\n  startTime: number;\n  startEpochId: number;\n  epochCount: number;\n}\n\nclass Mock {\n  private readonly options: MockOptions;\n\n  private time: number;\n  private epoch: number;\n  private round: number;\n  private step: number;\n\n  private readonly events: TraceEvent[];\n\n  constructor(options?: Optional<MockOptions>) {\n    this.events = [];\n    this.options = this.initialOptions(options);\n\n    const { startTime, startEpochId } = this.options;\n    this.time = startTime;\n    this.epoch = startEpochId;\n    this.round = 0;\n    this.step = 0;\n  }\n\n  initialOptions(options?: Optional<MockOptions>): MockOptions {\n    return Object.assign(\n      {\n        startEpochId: _.random(0, 10000000),\n        epochCount: 1200,\n        startTime: _.random(+new Date(2016, 1, 1), Date.now()),\n      },\n      options,\n    ) as MockOptions;\n  }\n\n  private consumeTime(max = 300) {\n    this.time += _.random(0, max);\n  }\n\n  private mockCustomEvent(n: number = 2) {\n    let i = _.random(0, n);\n    while (i--) {\n      this.consumeTime(30);\n      this.events.push(mockCustomEvent(this.time, this.epoch, this.round));\n    }\n  }\n\n  mock(): TraceEvent[] {\n    let count = this.options.epochCount;\n\n    while (count--) {\n      this.mockCustomEvent();\n      if (Math.random() < 0.05) {\n        this.consumeTime(3000);\n        this.epoch++;\n        continue;\n      }\n      this.consumeTime();\n      this.events.push(mockStartEpoch(this.time, this.epoch));\n\n      const round = _.random(0, 6);\n      while (this.round <= round) {\n        this.mockCustomEvent();\n\n        if (Math.random() < 0.05) {\n          this.consumeTime();\n          this.round++;\n          continue;\n        }\n        this.consumeTime();\n        this.events.push(mockStartRound(this.time, this.round));\n\n        const step = round === this.round ? 3 : _.random(0, 3);\n        while (this.step <= step) {\n          this.mockCustomEvent();\n\n          this.consumeTime();\n          this.events.push(mockStartStep(this.time, this.step));\n\n          this.step++;\n        }\n\n        this.step = 0;\n        this.round++;\n      }\n      this.round = 0;\n      this.epoch++;\n    }\n\n    return this.events;\n  }\n}\n\nexport { Mock };\n","import React, { useEffect, useMemo } from 'react';\nimport { useDropzone, DropzoneRootProps } from 'react-dropzone';\nimport { isEmpty } from 'lodash';\nimport { saveAs } from 'file-saver';\nimport { readJSONLog } from '../../helper';\nimport { TraceEvent } from '../../types';\nimport { Mock } from '../../mock';\n\nconst baseStyle = {\n  flex: 1,\n  display: 'flex',\n  flexDirection: 'column',\n  alignItems: 'center',\n  padding: '20px',\n  borderWidth: 2,\n  borderRadius: 2,\n  borderColor: '#eeeeee',\n  borderStyle: 'dashed',\n  outline: 'none',\n  transition: 'border .24s ease-in-out',\n};\n\nconst activeStyle = {\n  borderColor: '#2196f3',\n};\n\nconst acceptStyle = {\n  borderColor: '#00e676',\n};\n\nconst rejectStyle = {\n  borderColor: '#ff1744',\n};\n\nfunction saveFile() {\n  const filename = 'events.json';\n  const example: TraceEvent[] = new Mock().mock();\n\n  const blob = new Blob([JSON.stringify(example)], {\n    type: 'application/json',\n  });\n  saveAs(blob, filename);\n}\n\nexport function JSONLogReader({\n  onLoad,\n}: {\n  onLoad: (events: TraceEvent[]) => void;\n}) {\n  const {\n    getRootProps,\n    getInputProps,\n    isDragActive,\n    isDragAccept,\n    isDragReject,\n    acceptedFiles,\n  } = useDropzone({ accept: '.json', multiple: false });\n\n  useEffect(() => {\n    if (!isEmpty(acceptedFiles) && onLoad) {\n      readJSONLog(acceptedFiles[0]).then(onLoad);\n    }\n  }, [acceptedFiles]);\n\n  const style = useMemo(\n    () => ({\n      ...baseStyle,\n      ...(isDragActive ? activeStyle : {}),\n      ...(isDragAccept ? acceptStyle : {}),\n      ...(isDragReject ? rejectStyle : {}),\n    }),\n    [isDragAccept, isDragActive, isDragReject],\n  );\n\n  return (\n    <div className=\"container\">\n      <div {...getRootProps({ style } as DropzoneRootProps)}>\n        <input {...getInputProps()} />\n        <p>\n          Drag a parsed <strong>events.json</strong> here, or click to select\n          file\n        </p>\n      </div>\n      <div>\n        Or try this mock&nbsp;\n        <a onClick={() => saveFile()}>events.json</a>\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\nimport { useStoreActions, useStoreState } from '../store';\nimport { Profile } from './Profile';\nimport { JSONLogReader } from '../component/FileZone';\n\nexport const Guide = () => {\n  const eventLoaded = useStoreState(state => state.tracer.eventLoaded);\n  const loadEvents = useStoreActions(actions => actions.tracer.loadEvents);\n\n  if (eventLoaded) return <Profile />;\n  return <JSONLogReader onLoad={loadEvents} />;\n};\n","import {\n  action,\n  Action,\n  computed,\n  Computed,\n  createStore,\n  createTypedHooks,\n} from 'easy-peasy';\nimport { TraceEvent } from '../types';\nimport { isEmpty } from 'lodash';\nimport { EpochSlice, Events, RoundSlice } from '../event';\n\ninterface TracerModel {\n  events: TraceEvent[];\n  activeIndex: number | null;\n  activeEpoch: number | null;\n  activeRound: number | null;\n  activeStep: string | null;\n\n  slice: Computed<TracerModel, Events>;\n  epochSlice: Computed<TracerModel, EpochSlice>;\n  roundSlice: Computed<TracerModel, RoundSlice>;\n  eventLoaded: Computed<TracerModel, boolean>;\n  activeEvent: Computed<TracerModel, TraceEvent | null>;\n\n  activateEpoch: Action<TracerModel, number>;\n  inactivateEpoch: Action<TracerModel>;\n  loadEvents: Action<TracerModel, TraceEvent[]>;\n  activateEvent: Action<TracerModel, number>;\n  inactivateEvent: Action<TracerModel>;\n\n  activateRound: Action<TracerModel, number>;\n  inactivateRound: Action<TracerModel>;\n\n  activateStep: Action<TracerModel, string>;\n  inactivateStep: Action<TracerModel>;\n}\n\ninterface StoreModel {\n  tracer: TracerModel;\n}\n\nconst storeModel: StoreModel = {\n  tracer: {\n    events: [],\n    activeIndex: null,\n    activeEpoch: null,\n    activeRound: null,\n    activeStep: null,\n\n    slice: computed([state => state.events], events => {\n      console.log('events changed');\n      return new Events(events);\n    }),\n    epochSlice: computed(state => {\n      return state.slice.epoch(state.activeEpoch ?? -1);\n    }),\n    roundSlice: computed(state => {\n      return state.epochSlice.round(state.activeRound ?? -1);\n    }),\n    eventLoaded: computed(state => !isEmpty(state.events)),\n    activeEvent: computed(state =>\n      state.activeIndex === null ? null : state.events[state.activeIndex],\n    ),\n\n    loadEvents: action((state, events) => {\n      state.events = events;\n    }),\n    activateEvent: action((state, index) => {\n      state.activeIndex = index;\n    }),\n    inactivateEvent: action(state => {\n      state.activeIndex = null;\n    }),\n\n    activateEpoch: action((state, epochId) => {\n      state.activeEpoch = epochId;\n      state.activeRound = null;\n      state.activeIndex = null;\n    }),\n    inactivateEpoch: action(state => {\n      state.activeEpoch = null;\n    }),\n\n    activateRound: action((state, roundId) => {\n      state.activeRound = roundId;\n    }),\n\n    inactivateRound: action(state => {\n      state.activeRound = null;\n    }),\n\n    activateStep: action((state, stepName) => {\n      state.activeStep = stepName;\n    }),\n\n    inactivateStep: action(state => {\n      state.activeStep = null;\n    }),\n  },\n};\n\nconst typedHooks = createTypedHooks<StoreModel>();\nexport const store = createStore<StoreModel>(storeModel);\n\nexport const useStoreActions = typedHooks.useStoreActions;\nexport const useStoreDispatch = typedHooks.useStoreDispatch;\nexport const useStoreState = typedHooks.useStoreState;\n","import { EventType } from './constants';\n\nexport interface Tag {\n  epochId?: number;\n  roundId?: number;\n  stepName?: string;\n  [key: string]: null | string | number | undefined;\n}\n\nexport enum Keyframe {\n  START_EPOCH,\n  START_ROUND,\n  START_STEP,\n}\n\nexport type KeyframeKey = Keyframe;\n\nexport interface BaseEvent {\n  timestamp: number;\n  eventName: string;\n  tag?: Tag;\n}\n\nexport interface KeyframeEvent extends BaseEvent {\n  keyframe: Keyframe;\n}\n\nexport interface EpochKeyframe extends BaseEvent {\n  keyframe: Keyframe.START_EPOCH;\n  tag: Tag & { epochId: number };\n}\n\nexport interface RoundKeyframe extends BaseEvent {\n  keyframe: Keyframe.START_ROUND;\n  tag: Tag & { roundId: number };\n}\n\nexport interface StepKeyframe extends BaseEvent {\n  keyframe: Keyframe.START_STEP;\n  tag: Tag & { stepName: string };\n}\n\nexport interface ProposeEvent extends BaseEvent {\n  eventType: EventType.Propose;\n  tag: Tag & {\n    epochId: number;\n    roundId: number;\n    proposer: string;\n    hash: string;\n  };\n}\n\nexport interface VoteEvent extends BaseEvent {\n  eventType: EventType.Vote;\n  tag: Tag & {\n    epochId: number;\n    roundId: number;\n    voter: string;\n    hash: string;\n  };\n}\n\nexport type TraceEvent =\n  | BaseEvent\n  | EpochKeyframe\n  | RoundKeyframe\n  | StepKeyframe\n  | ProposeEvent\n  | VoteEvent;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import _ from 'lodash';\nimport {\n  EpochKeyframe,\n  Keyframe,\n  KeyframeEvent,\n  KeyframeKey,\n  ProposeEvent,\n  RoundKeyframe,\n  StepKeyframe,\n  TraceEvent,\n  VoteEvent,\n} from './types';\nimport { EventType } from './constants';\n\nexport function indexOfKeyframe(\n  events: TraceEvent[],\n  key: KeyframeKey,\n  value: string | number,\n): number {\n  return events.findIndex(event => {\n    if (!isKeyframe(event)) return false;\n    if (key === Keyframe.START_EPOCH && isKeyframeStartsOfEpoch(event)) {\n      return value === event.tag.epochId;\n    } else if (key === Keyframe.START_ROUND && isKeyframeStartsOfRound(event)) {\n      return value === event.tag.roundId;\n    } else if (key === Keyframe.START_STEP && isKeyframeStartsOfStep(event)) {\n      return value === event.tag.stepName;\n    }\n    return false;\n  });\n}\n\nexport function indexOfNextKeyframe(\n  events: TraceEvent[],\n  startIndex: number,\n): number {\n  return _.findIndex(events, event => 'keyframe' in event, startIndex + 1);\n}\n\nexport function isProposeEvent(event: TraceEvent): event is ProposeEvent {\n  return 'eventType' in event && event.eventType === EventType.Propose;\n}\n\nexport function isVoteEvent(event: TraceEvent): event is VoteEvent {\n  return 'eventType' in event && event.eventType === EventType.Vote;\n}\n\nexport function isKeyframe(event: TraceEvent): event is KeyframeEvent {\n  return 'keyframe' in event;\n}\n\nexport function isKeyframeStartsOfEpoch(\n  event: KeyframeEvent,\n): event is EpochKeyframe {\n  return event.keyframe === Keyframe.START_EPOCH;\n}\n\nexport function isKeyframeStartsOfRound(\n  event: KeyframeEvent,\n): event is RoundKeyframe {\n  return event.keyframe === Keyframe.START_ROUND;\n}\n\nexport function isKeyframeStartsOfStep(\n  event: KeyframeEvent,\n): event is StepKeyframe {\n  return event.keyframe === Keyframe.START_STEP;\n}\n\nexport function checkIsKeyframeOf(event: TraceEvent, key: Keyframe): boolean {\n  return isKeyframe(event) && event.keyframe === key;\n}\n\nexport function indexOfNextKeyframeByKey(\n  events: TraceEvent[],\n  startIndex: number,\n  key: KeyframeKey,\n) {\n  return _.findIndex(\n    events,\n    event => checkIsKeyframeOf(event, key),\n    startIndex + 1,\n  );\n}\n\nexport function filterProposeEvents(\n  events: TraceEvent[],\n  filter: {\n    epochId?: number;\n    roundId?: number;\n  },\n): ProposeEvent[] {\n  return _.filter(events.filter(isProposeEvent), { tag: filter });\n}\n\nexport function filterVoteEvents(\n  events: TraceEvent[],\n  filter: {\n    epochId?: number;\n    roundId?: number;\n  },\n): VoteEvent[] {\n  return _.filter(events.filter(isVoteEvent), { tag: filter });\n}\n\nexport interface Slice {\n  startAt: () => number;\n  endAt: () => number;\n  timeUsage: () => number;\n  timeRange: () => [number, number];\n  events: () => TraceEvent[];\n  nextSliceStartEvent: () => TraceEvent | null;\n}\n\nexport interface StepSlice extends Slice {\n  stepName: string;\n}\n\nexport interface RoundSlice extends Slice {\n  readonly roundId: number;\n  steps: () => StepSlice[];\n}\n\nexport interface EpochSlice extends Slice {\n  readonly epochId: number;\n  round: (roundId: number) => RoundSlice;\n  rounds: () => RoundSlice[];\n}\n\nabstract class BaseEvents<T> implements Slice {\n  readonly raw: TraceEvent[];\n  readonly startIndex: number;\n  readonly endIndex: number;\n  abstract readonly parent: T;\n\n  protected constructor(raw: TraceEvent[], ...sliceArgs: any) {\n    this.raw = raw;\n    const [start, end] = this.slice(raw, ...sliceArgs);\n    this.startIndex = start;\n    this.endIndex = end;\n  }\n\n  protected abstract slice(\n    events: TraceEvent[],\n    ...args: any\n  ): [number, number];\n\n  events = _.memoize<() => TraceEvent[]>(() => {\n    if (this.startIndex === -1 || this.endIndex === -1) return [];\n    return this.raw.slice(this.startIndex, this.endIndex + 1);\n  });\n\n  nextSliceStartEvent: () => TraceEvent | null = () => {\n    if (this.startIndex === -1 || this.endIndex === -1) return null;\n    return this.raw[indexOfNextKeyframe(this.raw, this.endIndex)];\n  };\n\n  timeRange: () => [number, number] = () => {\n    if (this.startIndex === -1 || this.endIndex === -1) return [0, 0];\n    const nextKeyframe = this.nextSliceStartEvent();\n    if (!nextKeyframe) return [0, 0];\n    return [this.raw[this.startIndex].timestamp, nextKeyframe.timestamp];\n  };\n\n  startAt = () => this.raw[this.startIndex]?.timestamp ?? 0;\n\n  endAt = () => this.nextSliceStartEvent()?.timestamp ?? 0;\n\n  timeUsage = () => this.endAt() - this.startAt();\n}\n\nexport class EpochEvents extends BaseEvents<Events> implements EpochSlice {\n  readonly epochId: number;\n  readonly parent: Events;\n\n  constructor(raw: TraceEvent[], epochId: number, parent?: Events) {\n    super(raw, epochId);\n    this.epochId = epochId;\n    this.parent = parent as Events;\n  }\n\n  protected slice(events: TraceEvent[], epochId: number): [number, number] {\n    const start = indexOfKeyframe(events, Keyframe.START_EPOCH, epochId);\n    const end =\n      indexOfNextKeyframeByKey(events, start, Keyframe.START_EPOCH) - 1;\n    return [start, end];\n  }\n\n  rounds(): RoundSlice[] {\n    const epochEvents = this.events();\n    if (_.isEmpty(epochEvents)) return [];\n\n    const self = this;\n    return epochEvents\n      .filter<KeyframeEvent>(isKeyframe)\n      .filter<RoundKeyframe>(isKeyframeStartsOfRound)\n      .map<RoundSlice>(event => new RoundEvents(event.tag.roundId, self));\n  }\n\n  round(roundId: number): RoundSlice {\n    return new RoundEvents(roundId, this);\n  }\n\n  static empty(): EpochEvents {\n    return new EpochEvents([], -1);\n  }\n}\n\nexport class RoundEvents extends BaseEvents<EpochEvents> implements RoundSlice {\n  readonly roundId: number;\n  readonly parent: EpochEvents;\n\n  constructor(roundId: number, parent: EpochEvents) {\n    super(parent.raw, roundId, parent);\n    this.roundId = roundId;\n    this.parent = parent;\n  }\n\n  protected slice(\n    events: TraceEvent[],\n    roundId: number,\n    parentSlice: EpochEvents,\n  ): [number, number] {\n    const epochEvents = parentSlice.events();\n    const start = indexOfKeyframe(epochEvents, Keyframe.START_ROUND, roundId);\n    if (start === -1) return [0, 0];\n    const nextRoundIndex = indexOfNextKeyframeByKey(\n      epochEvents,\n      start,\n      Keyframe.START_ROUND,\n    );\n    const end =\n      nextRoundIndex === -1 ? epochEvents.length - 1 : nextRoundIndex - 1;\n    const offset = parentSlice.startIndex;\n    return [start + offset, end + offset];\n  }\n\n  steps: () => StepSlice[] = () => {\n    const roundEvents = this.events();\n    if (_.isEmpty(roundEvents)) return [];\n\n    const self = this;\n    return roundEvents\n      .filter<KeyframeEvent>(isKeyframe)\n      .filter<StepKeyframe>(isKeyframeStartsOfStep)\n      .map<StepSlice>(event => new StepEvents(event.tag.stepName, self));\n  };\n\n  static empty(): RoundEvents {\n    return new RoundEvents(-1, EpochEvents.empty());\n  }\n}\n\nexport class StepEvents extends BaseEvents<RoundEvents> implements StepSlice {\n  readonly stepName: string;\n  readonly parent: RoundEvents;\n\n  constructor(stepName: string, parent: RoundEvents) {\n    super(parent.raw, stepName, parent);\n    this.stepName = stepName;\n    this.parent = parent;\n  }\n\n  slice(\n    raw: TraceEvent[],\n    stepName: string,\n    parent: RoundEvents,\n  ): [number, number] {\n    const parentEvents = parent.events();\n    const start = indexOfKeyframe(parentEvents, Keyframe.START_STEP, stepName);\n    if (start === -1) return [0, 0];\n    const nextStepIndex = indexOfNextKeyframeByKey(\n      parentEvents,\n      start,\n      Keyframe.START_STEP,\n    );\n    const end =\n      nextStepIndex === -1 ? parentEvents.length - 1 : nextStepIndex - 1;\n    const offset = parent.startIndex;\n    return [start + offset, end + offset];\n  }\n}\n\nexport class Events extends BaseEvents<null> implements Slice {\n  readonly parent = null;\n\n  constructor(raw: TraceEvent[]) {\n    super(raw);\n  }\n\n  protected slice(events: TraceEvent[]): [number, number] {\n    return [0, events.length];\n  }\n\n  roundCountEachEpoch(): Map<number, number> {\n    const events = this.raw;\n    const epochRoundMap: Map<number, number> = new Map();\n\n    let epoch = -1;\n    let round = -1;\n    for (const event of events) {\n      if (!isKeyframe(event)) continue;\n      if (isKeyframeStartsOfEpoch(event)) {\n        const newEpoch = event.tag.epochId;\n\n        // the first epoch appears in events\n        if (epoch === -1) {\n          epoch = newEpoch;\n          continue;\n        }\n\n        if (newEpoch - epoch === 1) {\n          epochRoundMap.set(epoch, round + 1);\n        } else {\n          // set round be -1 when the epoch is skipped\n          _.range(epoch, newEpoch).forEach(e => epochRoundMap.set(e, -1));\n        }\n\n        epoch = newEpoch;\n      } else if (isKeyframeStartsOfRound(event)) {\n        round = event.tag.roundId;\n      }\n    }\n    return epochRoundMap;\n  }\n\n  epoch(epochId: number): EpochEvents {\n    return new EpochEvents(this.raw, epochId, this);\n  }\n}\n","export enum EventType {\n    Propose,\n    Vote,\n    Error,\n    Custom,\n}\n\nexport enum EventScopeType {\n    Global,\n    Epoch,\n    Round,\n    Step,\n}"],"sourceRoot":""}