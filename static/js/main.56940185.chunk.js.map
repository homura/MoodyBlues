{"version":3,"sources":["event.ts","store/index.ts","container/Header.tsx","component/SVGTooltip.tsx","component/Heatmap.tsx","container/RoundHeatmap.tsx","helper.ts","container/EventDetail.tsx","container/EventList.tsx","container/EpochTimeline.tsx","container/EpochOverview.tsx","container/Profile.tsx","mock.ts","component/FileZone/index.tsx","container/Guide.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["indexOfKeyframe","events","key","value","findIndex","event","keyframe","indexOfNextKeyframe","startIndex","_","indexOfNextKeyframeByKey","valueOfKeyframe","defaults","BaseEvents","raw","endIndex","parent","memoize","slice","nextSliceStartEvent","nextKeyframeIndex","timeRange","nextKeyframe","timestamp","this","sliceArgs","start","end","EpochEvents","epochId","epochEvents","isEmpty","self","filter","checkIsKeyframeOf","map","RoundEvents","idOfRoundKeyframe","roundId","steps","Events","length","epochRoundMap","Map","epoch","round","newEpoch","set","range","forEach","e","storeModel","tracer","activeIndex","activeEpoch","computed","state","eventLoaded","activeEvent","loadEvents","action","activateEvent","index","inactivateEvent","activateEpoch","inactivateEpoch","typedHooks","createTypedHooks","store","createStore","useStoreActions","useStoreState","useStoreDispatch","Header","Logo","styled","div","AppHeader","type","SVGTooltip","props","followCursor","plugins","LegendItemWrapper","span","LegendItem","fill","label","width","height","x","y","Heatmap","withSize","size","data","columnCount","Math","floor","scale","scaleLinear","domain","useState","tooltipContent","setTooltipContent","cells","useMemo","transform","item","i","interpolateGreens","onMouseOver","onTooltip","onClick","onCellClick","animation","content","style","padding","RoundHeatmap","actions","roundCountEachEpoch","Array","from","keys","values","epochIds","roundIds","formatDate","date","pattern","format","theme","scheme","base00","base01","base02","base03","base04","base05","base06","base07","base08","base09","base0A","base0B","base0C","base0D","base0E","base0F","EventDetail","tag","get","eventName","invertTheme","hideRoot","EventName","EventList","columns","title","dataIndex","render","name","record","position","overflow","pagination","rowKey","String","dataSource","scroll","placement","onClose","visible","mask","getContainer","EpochTimeline","timeUsage","setTimeUsage","whiteSpace","rounds","strokeWidth","stroke","dominantBaseline","textAnchor","EpochOverview","roundCount","last","gutter","Profile","mockStartRound","mockStartStep","step","stepName","ns","vn","flatMap","v","n","ts","address","lock","random","tx","proposal","mockCustomEvent","sample","Mock","options","time","initialOptions","startTime","startEpochId","Object","assign","epochCount","Date","now","max","consumeTime","push","count","baseStyle","flex","display","flexDirection","alignItems","borderWidth","borderRadius","borderColor","borderStyle","outline","transition","activeStyle","acceptStyle","rejectStyle","JSONLogReader","onLoad","useDropzone","accept","multiple","getRootProps","getInputProps","isDragActive","isDragAccept","isDragReject","acceptedFiles","useEffect","file","Promise","resolve","reject","reader","FileReader","onload","result","JSON","parse","readAsText","then","className","example","mock","blob","Blob","stringify","saveAs","saveFile","Guide","Content","App","Boolean","window","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.56940185.chunk.js","sourcesContent":["import _ from 'lodash';\nimport { KeyframeKey, TraceEvent } from './types';\n\nexport function indexOfKeyframe(\n  events: TraceEvent[],\n  key: KeyframeKey,\n  value: string | number,\n): number {\n  // @ts-ignore\n  return events.findIndex(event => event.keyframe?.[key] === value);\n}\n\nexport function indexOfNextKeyframe(\n  events: TraceEvent[],\n  startIndex: number,\n): number {\n  return _.findIndex(events, event => 'keyframe' in event, startIndex + 1);\n}\n\nexport function indexOfNextKeyframeByKey(\n  events: TraceEvent[],\n  startIndex: number,\n  key: KeyframeKey,\n) {\n  return _.findIndex(\n    events,\n    event => !!(event.keyframe && key in event.keyframe),\n    startIndex + 1,\n  );\n}\n\nexport function checkIsKeyframeOf(\n  event: TraceEvent,\n  key: KeyframeKey,\n): boolean {\n  const keyframe = event.keyframe;\n  return !!(keyframe && key in keyframe);\n}\n\nexport function valueOfKeyframe<T>(\n  event: TraceEvent,\n  key: KeyframeKey,\n  defaults: T,\n): T {\n  const keyframe = event.keyframe;\n  if (!keyframe || !(key in keyframe)) return defaults;\n  // @ts-ignore\n  return keyframe[key];\n}\n\nexport function idOfEpochKeyframe(event: TraceEvent): number {\n  return valueOfKeyframe(event, 'epochId', -1);\n}\n\nexport function idOfRoundKeyframe(event: TraceEvent): number {\n  return valueOfKeyframe(event, 'roundId', -1);\n}\n\nexport function stepNameOfKeyframe(event: TraceEvent): string {\n  return valueOfKeyframe(event, 'stepName', '');\n}\n\nexport function eventsBetweenKeyframe(\n  events: TraceEvent[],\n  key: 'epochId' | 'roundId' | 'stepName',\n  value: string | number,\n): TraceEvent[] {\n  const startIndex = indexOfKeyframe(events, key, value);\n  if (startIndex === -1) return [];\n  const endIndex = indexOfNextKeyframe(events, startIndex);\n\n  return events.slice(startIndex, endIndex);\n}\n\ninterface Slice {\n  timeRange: () => [number, number] | null;\n  events: () => TraceEvent[];\n  nextSliceStartEvent: () => TraceEvent | null;\n}\n\ninterface StepSlice extends Slice {\n  parentSlice: () => RoundSlice;\n  stepName: string;\n}\n\ninterface RoundSlice extends Slice {\n  readonly roundId: number;\n  steps: () => StepSlice[] | null;\n}\n\nexport interface EpochSlice extends Slice {\n  readonly epochId: number;\n  rounds: () => RoundSlice[] | null;\n}\n\nabstract class BaseEvents<T> implements Slice {\n  readonly raw: TraceEvent[];\n  readonly startIndex: number;\n  readonly endIndex: number;\n  abstract readonly parent: T;\n\n  protected constructor(raw: TraceEvent[], ...sliceArgs: any) {\n    this.raw = raw;\n    const [start, end] = this.slice(raw, ...sliceArgs);\n    this.startIndex = start;\n    this.endIndex = end;\n  }\n\n  protected abstract slice(\n    events: TraceEvent[],\n    ...args: any\n  ): [number, number];\n\n  events = _.memoize<() => TraceEvent[]>(() => {\n    if (this.startIndex === -1 || this.endIndex === -1) return [];\n    return this.raw.slice(this.startIndex, this.endIndex + 1);\n  });\n\n  nextSliceStartEvent: () => TraceEvent | null = () => {\n    if (this.startIndex === -1 || this.endIndex === -1) return null;\n    const nextKeyframeIndex = indexOfNextKeyframe(this.raw, this.endIndex);\n    if (nextKeyframeIndex === -1) return null;\n    return this.raw[nextKeyframeIndex];\n  };\n\n  timeRange: () => [number, number] | null = () => {\n    if (this.startIndex === -1 || this.endIndex === -1) return null;\n    const nextKeyframe = this.nextSliceStartEvent();\n    if (!nextKeyframe) return null;\n    return [this.raw[this.startIndex].timestamp, nextKeyframe.timestamp];\n  };\n}\n\nexport class EpochEvents extends BaseEvents<Events> implements EpochSlice {\n  readonly epochId: number;\n  readonly parent: Events;\n\n  constructor(raw: TraceEvent[], epochId: number, parent?: Events) {\n    super(raw, epochId);\n    this.epochId = epochId;\n    this.parent = parent as Events;\n  }\n\n  protected slice(events: TraceEvent[], epochId: number): [number, number] {\n    const start = indexOfKeyframe(events, 'epochId', epochId);\n    const end = indexOfNextKeyframeByKey(events, start, 'epochId') - 1;\n    return [start, end];\n  }\n\n  rounds(): RoundSlice[] | null {\n    const epochEvents = this.events();\n    if (_.isEmpty(epochEvents)) return null;\n\n    const self = this;\n    return epochEvents\n      .filter(event => checkIsKeyframeOf(event, 'roundId'))\n      .map<RoundSlice>(\n        event => new RoundEvents(idOfRoundKeyframe(event), self),\n      );\n  }\n}\n\nexport class RoundEvents extends BaseEvents<EpochEvents> implements RoundSlice {\n  readonly roundId: number;\n  readonly parent: EpochEvents;\n\n  constructor(roundId: number, parent: EpochEvents) {\n    super(parent.raw, roundId, parent);\n    this.roundId = roundId;\n    this.parent = parent;\n  }\n\n  protected slice(\n    events: TraceEvent[],\n    roundId: number,\n    parent: EpochEvents,\n  ): [number, number] {\n    const epochEvents = parent.events();\n    const start =\n      indexOfKeyframe(epochEvents, 'roundId', roundId) + parent.startIndex;\n    if (start === -1) return [-1, -1];\n    const end = indexOfNextKeyframeByKey(events, start, 'roundId') - 1;\n\n    return [start, end];\n  }\n\n  steps: () => StepSlice[] | null = () => {\n    return null;\n  };\n}\n\nexport class Events extends BaseEvents<null> implements Slice {\n  readonly parent = null;\n\n  constructor(raw: TraceEvent[]) {\n    super(raw);\n  }\n\n  protected slice(events: TraceEvent[]): [number, number] {\n    return [0, events.length];\n  }\n\n  roundCountEachEpoch(): Map<number, number> {\n    const events = this.raw;\n    const epochRoundMap: Map<number, number> = new Map();\n\n    let epoch = -1;\n    let round = -1;\n    for (const event of events) {\n      let keyframe = event.keyframe;\n      if (!keyframe) continue;\n      if ('epochId' in keyframe) {\n        const newEpoch = keyframe.epochId;\n\n        // the first epoch appears in events\n        if (epoch === -1) {\n          epoch = newEpoch;\n          continue;\n        }\n\n        if (newEpoch - epoch === 1) {\n          epochRoundMap.set(epoch, round + 1);\n        } else {\n          // set round be -1 when the epoch is skipped\n          _.range(epoch, newEpoch).forEach(e => epochRoundMap.set(e, -1));\n        }\n\n        epoch = newEpoch;\n      } else if ('roundId' in keyframe) {\n        round = keyframe.roundId;\n      }\n    }\n    return epochRoundMap;\n  }\n\n  epoch(epochId: number): EpochEvents {\n    return new EpochEvents(this.raw, epochId, this);\n  }\n}\n","import {\n  action,\n  Action,\n  computed,\n  Computed,\n  createStore,\n  createTypedHooks,\n} from 'easy-peasy';\nimport { TraceEvent } from '../types';\nimport { isEmpty } from 'lodash';\nimport { Events } from '../event';\n\ntype NestedEvent = Map<string, Map<string, TraceEvent>>;\n\ninterface TracerModel {\n  events: TraceEvent[];\n  activeIndex: number | null;\n  activeEpoch: number | null;\n\n  slice: Computed<TracerModel, Events>;\n  eventLoaded: Computed<TracerModel, boolean>;\n  activeEvent: Computed<TracerModel, TraceEvent | null>;\n\n  activateEpoch: Action<TracerModel, number>;\n  inactivateEpoch: Action<TracerModel>;\n  loadEvents: Action<TracerModel, TraceEvent[]>;\n  activateEvent: Action<TracerModel, number>;\n  inactivateEvent: Action<TracerModel>;\n}\n\ninterface StoreModel {\n  tracer: TracerModel;\n}\n\nconst storeModel: StoreModel = {\n  tracer: {\n    events: [],\n    activeIndex: null,\n    activeEpoch: null,\n\n    slice: computed(state => {\n      return new Events(state.events);\n    }),\n    eventLoaded: computed(state => !isEmpty(state.events)),\n    activeEvent: computed(state =>\n      state.activeIndex === null ? null : state.events[state.activeIndex],\n    ),\n\n    loadEvents: action((state, events) => {\n      state.events = events;\n    }),\n    activateEvent: action((state, index) => {\n      state.activeIndex = index;\n    }),\n    inactivateEvent: action(state => {\n      state.activeIndex = null;\n    }),\n\n    activateEpoch: action((state, epochId) => {\n      state.activeEpoch = epochId;\n      state.activeIndex = null;\n    }),\n    inactivateEpoch: action(state => {\n      state.activeEpoch = null;\n    }),\n  },\n};\n\nconst typedHooks = createTypedHooks<StoreModel>();\nexport const store = createStore<StoreModel>(storeModel);\n\nexport const useStoreActions = typedHooks.useStoreActions;\nexport const useStoreDispatch = typedHooks.useStoreDispatch;\nexport const useStoreState = typedHooks.useStoreState;\n","import React from 'react';\nimport { Icon, Layout } from 'antd';\nimport styled from 'styled-components';\n\nconst Header = Layout.Header;\n\nconst Logo = styled.div`\n  width: 120px;\n  height: 31px;\n  margin: 16px 24px 16px 0;\n  line-height: 32px;\n  float: left;\n  font-weight: bold;\n`;\n\nexport const AppHeader: React.FC = () => {\n  return (\n    <Header>\n      <Logo>\n        <Icon type=\"play-circle\" /> Moody Blues\n      </Logo>\n    </Header>\n  );\n};\n","import React from 'react';\nimport Tippy, { TippyProps } from '@tippy.js/react';\nimport { followCursor } from 'tippy.js';\nimport 'tippy.js/dist/tippy.css';\n\nexport const SVGTooltip = (props: TippyProps) => {\n  return <Tippy followCursor={true} plugins={[followCursor]} {...props} />;\n};\n","import React, { ReactChild, ReactElement, useMemo, useState } from 'react';\nimport { interpolateGreens } from 'd3-scale-chromatic';\nimport { scaleLinear } from 'd3-scale';\nimport { SizeMeProps, withSize } from 'react-sizeme';\nimport styled from 'styled-components';\nimport { SVGTooltip } from './SVGTooltip';\n\nconst LegendItemWrapper = styled.span`\n  margin-right: 8px;\n\n  svg {\n    vertical-align: middle;\n  }\n`;\n\nconst LegendItem = ({ fill, label }: { fill: string; label: string }) => {\n  return (\n    <LegendItemWrapper>\n      <svg width={15} height={15}>\n        <rect x={0} y={0} width={12} height={12} fill={fill} />\n      </svg>\n      <span>{label}</span>\n    </LegendItemWrapper>\n  );\n};\n\nexport type HeatmapProps = SizeMeProps & {\n  data: number[];\n  domain: number[];\n  range: number[];\n  onTooltip?: (index: number) => ReactChild;\n  onCellClick?: (index: number) => void;\n};\n\nexport const Heatmap = withSize()((props: HeatmapProps) => {\n  const width = (props.size.width as number) - 20;\n  const height = 200 - 20;\n\n  const { data } = props;\n\n  const cellSize = 12;\n  const paddedCellSize = 15;\n  const columnCount = Math.floor(height / paddedCellSize - 1);\n\n  const scale = scaleLinear()\n    .domain([0, 3, 5])\n    .range([0, 0.8, 1]);\n\n  const [tooltipContent, setTooltipContent] = useState<ReactChild | undefined>(\n    '',\n  );\n\n  const cells = useMemo(\n    () => (\n      <g transform={`translate(20,20)`}>\n        {data.map((item, i) => {\n          return (\n            <rect\n              key={i}\n              x={paddedCellSize * Math.floor(i / columnCount)}\n              y={paddedCellSize * (i % columnCount)}\n              width={cellSize}\n              height={cellSize}\n              fill={item === -1 ? '#ebedf0' : interpolateGreens(scale(item))}\n              onMouseOver={() => setTooltipContent(props.onTooltip?.(i))}\n              onClick={() => props.onCellClick?.(i)}\n            />\n          );\n        })}\n      </g>\n    ),\n    [data],\n  );\n\n  return (\n    <div>\n      <svg width={width} height={height}>\n        <SVGTooltip animation=\"fade\" content={tooltipContent as ReactChild}>\n          {cells}\n        </SVGTooltip>\n      </svg>\n      <div style={{ padding: '0 20px' }}>\n        <LegendItem fill=\"#ebedf0\" label=\"incomplete\" />\n        <LegendItem fill={interpolateGreens(scale(1))} label=\"1\" />\n        <LegendItem fill={interpolateGreens(scale(3))} label=\"3\" />\n        <LegendItem fill={interpolateGreens(scale(5))} label=\"≥ 5\" />\n      </div>\n    </div>\n  );\n});\n","import React, { useMemo } from 'react';\nimport { Heatmap } from '../component/Heatmap';\nimport { Events } from '../event';\nimport { useStoreActions, useStoreState } from '../store';\n\nexport const RoundHeatmap = () => {\n  const events = useStoreState(state => state.tracer.events);\n  const activateEpoch = useStoreActions(\n    actions => actions.tracer.activateEpoch,\n  );\n\n  const [epochIds, roundIds] = useMemo((): [number[], number[]] => {\n    const epochRoundMap = new Events(events).roundCountEachEpoch();\n    const epochIds = Array.from(epochRoundMap.keys());\n    const roundIds = Array.from(epochRoundMap.values());\n    return [epochIds, roundIds];\n  }, [events]);\n\n  return (\n    <Heatmap\n      domain={[0, 3, 5]}\n      range={[0, 0.8, 1]}\n      data={roundIds}\n      onCellClick={i => activateEpoch(epochIds[i])}\n      onTooltip={i => (\n        <div>\n          epoch: {epochIds[i]} <br /> round: {roundIds[i]}\n        </div>\n      )}\n    />\n  );\n};\n","import { format } from 'date-fns';\nimport { TraceEvent } from './types';\n\nfunction hashCode(str: string) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash = str.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  return hash;\n}\n\nfunction intToRGB(i: number) {\n  const c = (i & 0x00ffffff).toString(16).toUpperCase();\n  return '00000'.substring(0, 6 - c.length) + c;\n}\n\nexport function anyStrToColor(str: string): string {\n  return '#' + intToRGB(hashCode(str));\n}\n\nexport function readJSONLog(file: File): Promise<TraceEvent[]> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      const events = reader.result as string;\n      resolve(JSON.parse(events));\n    };\n    reader.readAsText(file);\n  });\n}\n\nexport function formatDate(date: Date | number, pattern?: string) {\n  pattern = pattern ?? 'yyyy-MM-dd HH:mm:ss:SSS';\n  return format(date, pattern);\n}\n\n","import React from 'react';\nimport { Drawer, Divider, Row, Col } from 'antd';\nimport JSONTree from 'react-json-tree';\nimport _ from 'lodash';\nimport { TraceEvent } from '../types';\nimport { formatDate } from '../helper';\n\nconst theme = {\n  scheme: 'monokai',\n  base00: 'unset',\n  base01: '#383830',\n  base02: '#49483e',\n  base03: '#75715e',\n  base04: '#a59f85',\n  base05: '#f8f8f2',\n  base06: '#f5f4f1',\n  base07: '#f9f8f5',\n  base08: '#f92672',\n  base09: '#fd971f',\n  base0A: '#f4bf75',\n  base0B: '#a6e22e',\n  base0C: '#a1efe4',\n  base0D: '#66d9ef',\n  base0E: '#ae81ff',\n  base0F: '#cc6633',\n};\n\ninterface EventDetailProps {\n  event: TraceEvent;\n}\n\nexport const EventDetail = (props: EventDetailProps) => {\n  const { event } = props;\n  if (!event) return null;\n\n  const tag = { tag: _.get(event, 'tag') } as {};\n\n  return (\n    <div>\n      <Row>\n        <Col span={8}>name</Col>\n        <Col span={16}>{event.eventName}</Col>\n\n        <Col span={8}>time</Col>\n        <Col span={16}>{formatDate(event.timestamp)}</Col>\n      </Row>\n      <Divider />\n      <JSONTree data={tag} theme={theme} invertTheme={false} hideRoot={true} />\n    </div>\n  );\n};\n","import React from 'react';\nimport { Drawer, Table } from 'antd';\nimport styled from 'styled-components';\nimport { useStoreActions, useStoreState } from '../store';\nimport { TraceEvent } from '../types';\nimport { EventDetail } from './EventDetail';\nimport { formatDate } from '../helper';\n\nconst EventName = styled.div`\n  cursor: pointer;\n`;\n\ninterface EventListProp {}\n\nexport const EventList = (props: EventListProp) => {\n  const { slice, activeEpoch, activeEvent } = useStoreState(\n    state => state.tracer,\n  );\n  const { activateEvent, inactivateEvent } = useStoreActions(\n    actions => actions.tracer,\n  );\n  if (activeEpoch === null) return null;\n  const epoch = slice.epoch(activeEpoch);\n  const epochEvents = epoch.events();\n\n  const columns = [\n    {\n      key: 'Name',\n      title: 'Name',\n      dataIndex: 'eventName',\n      render: (name: string, record: TraceEvent, index: number) => (\n        <EventName onClick={() => activateEvent(index + epoch.startIndex)}>\n          {name}\n        </EventName>\n      ),\n    },\n    {\n      key: 'Timestamp',\n      title: 'Timestamp',\n      dataIndex: 'timestamp',\n      render: (timestamp: number) => formatDate(timestamp),\n    },\n  ];\n\n  return (\n    <div style={{ position: 'relative', overflow: 'hidden' }}>\n      <Table\n        size=\"small\"\n        pagination={false}\n        rowKey={(record: TraceEvent, i) => String(i)}\n        dataSource={epochEvents}\n        columns={columns}\n        scroll={{ y: 300 }}\n      />\n\n      <Drawer\n        placement=\"right\"\n        width={400}\n        onClose={() => inactivateEvent()}\n        visible={!!activeEvent}\n        mask={false}\n        getContainer={false}\n        style={{ position: 'absolute' }}\n      >\n        <EventDetail event={activeEvent as TraceEvent} />\n      </Drawer>\n    </div>\n  );\n};\n","import React, { useState } from 'react';\nimport { withSize, SizeMeProps } from 'react-sizeme';\nimport { scaleLinear } from 'd3-scale';\nimport { useStoreState } from '../store';\nimport { SVGTooltip } from '../component/SVGTooltip';\n\ntype EpochTimelineProps = SizeMeProps & {};\n\nexport const EpochTimeline = withSize()((props: EpochTimelineProps) => {\n  const { slice, activeEpoch } = useStoreState(state => state.tracer);\n  const [timeUsage, setTimeUsage] = useState(0);\n\n  if (activeEpoch === null) return null;\n\n  const epoch = slice.epoch(activeEpoch);\n  const domain = epoch.timeRange();\n  if (!domain) return null;\n\n  const width = props.size.width as number;\n\n  const scale = scaleLinear()\n    .domain([0, domain[1] - domain[0]])\n    .range([0, width - 50]);\n\n  return (\n    <div style={{ whiteSpace: 'nowrap' }}>\n      <div>Timeline</div>\n      <SVGTooltip content={`${timeUsage}ms`}>\n        <div>\n          {epoch?.rounds()?.map(round => {\n            const timeRange = round.timeRange();\n            const roundId = round.roundId;\n            if (!timeRange) return null;\n            const [start, end] = timeRange;\n            const timeUsage = end - start;\n            return (\n              <svg\n                key={roundId}\n                width={scale(timeUsage)}\n                height={15}\n                onMouseOver={() => setTimeUsage(timeUsage)}\n              >\n                <g key={round.roundId}>\n                  <rect\n                    x={0}\n                    y={0}\n                    width=\"100%\"\n                    height={15}\n                    style={{\n                      fill: '#eec360',\n                      strokeWidth: 1,\n                      stroke: '#333333',\n                    }}\n                  />\n                  <text\n                    x=\"50%\"\n                    y=\"50%\"\n                    dominantBaseline=\"middle\"\n                    textAnchor=\"middle\"\n                    fill=\"#333333\"\n                  >\n                    R{round.roundId}\n                  </text>\n                </g>\n              </svg>\n            );\n          })}\n        </div>\n      </SVGTooltip>\n    </div>\n  );\n});\n","import React from 'react';\nimport { Row, Col, Statistic } from 'antd';\nimport _ from 'lodash';\nimport { useStoreState } from '../store';\nimport { EpochTimeline } from './EpochTimeline';\n\ninterface EpochOverviewProps {}\n\nexport const EpochOverview = (props: EpochOverviewProps) => {\n  const { activeEpoch, slice } = useStoreState(state => state.tracer);\n\n  if (activeEpoch === null) return null;\n\n  const roundCount: number =\n    (_.last(slice.epoch(activeEpoch).rounds())?.roundId ?? -1) + 1;\n\n  return (\n    <Row gutter={16} style={{ padding: '8px' }}>\n      <Col span={6}>\n        <Statistic title=\"Epoch\" value={activeEpoch} />\n      </Col>\n      <Col span={6}>\n        <Statistic title=\"Round usage\" value={roundCount} />\n      </Col>\n      <Col span={12}>\n        <EpochTimeline />\n      </Col>\n    </Row>\n  );\n};\n","import React from 'react';\nimport { RoundHeatmap } from './RoundHeatmap';\nimport { EventList } from './EventList';\nimport { EpochOverview } from './EpochOverview';\n\nexport const Profile: React.FC = () => {\n  return (\n    <div>\n      <RoundHeatmap />\n      <div style={{ padding: '4px' }}>\n        <EpochOverview />\n        <EventList />\n      </div>\n    </div>\n  );\n};\n","import _ from 'lodash';\nimport { Optional } from 'utility-types';\nimport { KeyValue, TraceEvent } from './types';\n\nfunction mockStartEpoch(timestamp: number, epochId: number): TraceEvent {\n  return {\n    timestamp,\n    eventName: 'goto_new_epoch',\n    keyframe: {\n      epochId,\n    },\n  };\n}\n\nfunction mockStartRound(timestamp: number, roundId: number): TraceEvent {\n  return {\n    timestamp,\n    eventName: 'goto_new_round',\n    keyframe: {\n      roundId,\n    },\n  };\n}\n\nconst steps = ['propose', 'prevote', 'precommit', 'commit'];\nfunction mockStartStep(timestamp: number, step: number): TraceEvent {\n  const stepName = steps[step];\n  return {\n    eventName: stepName,\n    timestamp,\n    keyframe: {\n      stepName,\n    },\n  };\n}\n\nconst vs: string[] = [\n  'check',\n  'get',\n  'receive',\n  'request',\n  'start',\n  'validate',\n];\nconst ns: string[] = ['epoch', 'tx', 'proposal', 'vote', 'lock'];\nconst vn: string[] = vs.flatMap(v => ns.map(n => `${v}_${n}`));\n\nconst ts: KeyValue[] = [\n  { address: '0x10000000000000000000000000000000000000' },\n  {\n    address: '0x10000000000000000000000000000000000000',\n    lock: '0x10000000000000000000000000000000000000',\n  },\n  {\n    key: Math.random(),\n  },\n  {\n    tx: '0x10000000000000000000000000000000000000',\n    proposal: '0x10000000000000000000000000000000000000',\n  },\n];\n\nfunction mockTag(): KeyValue | undefined {\n  return _.sample(ts);\n}\n\nfunction mockCustomEvent(timestamp: number): TraceEvent {\n  return {\n    timestamp,\n    eventName: _.sample(vn) as string,\n    tag: mockTag(),\n  };\n}\n\ninterface MockOptions {\n  startTime: number;\n  startEpochId: number;\n  epochCount: number;\n}\n\nclass Mock {\n  private readonly options: MockOptions;\n\n  private time: number;\n  private epoch: number;\n  private round: number;\n  private step: number;\n\n  private readonly events: TraceEvent[];\n\n  constructor(options?: Optional<MockOptions>) {\n    this.events = [];\n    this.options = this.initialOptions(options);\n\n    const { startTime, startEpochId } = this.options;\n    this.time = startTime;\n    this.epoch = startEpochId;\n    this.round = 0;\n    this.step = 0;\n  }\n\n  initialOptions(options?: Optional<MockOptions>): MockOptions {\n    return Object.assign(\n      {\n        startEpochId: _.random(0, 10000000),\n        epochCount: 1200,\n        startTime: _.random(+new Date(2016, 1, 1), Date.now()),\n      },\n      options,\n    ) as MockOptions;\n  }\n\n  private consumeTime(max = 300) {\n    this.time += _.random(0, max);\n  }\n\n  private mockCustomEvent(n: number = 2) {\n    let i = _.random(0, n);\n    while (i--) {\n      this.consumeTime(30);\n      this.events.push(mockCustomEvent(this.time));\n    }\n  }\n\n  mock(): TraceEvent[] {\n    let count = this.options.epochCount;\n\n    while (count--) {\n      this.mockCustomEvent();\n      if (Math.random() < 0.05) {\n        this.consumeTime(3000);\n        this.epoch++;\n        continue;\n      }\n      this.consumeTime();\n      this.events.push(mockStartEpoch(this.time, this.epoch));\n\n      const round = _.random(0, 6);\n      while (this.round <= round) {\n        this.mockCustomEvent();\n\n        if (Math.random() < 0.05) {\n          this.consumeTime();\n          this.round++;\n          continue;\n        }\n        this.consumeTime();\n        this.events.push(mockStartRound(this.time, this.round));\n\n        const step = round === this.round ? 3 : _.random(0, 3);\n        while (this.step <= step) {\n          this.mockCustomEvent();\n\n          this.consumeTime();\n          this.events.push(mockStartStep(this.time, this.step));\n\n          this.step++;\n        }\n\n        this.step = 0;\n        this.round++;\n      }\n      this.round = 0;\n      this.epoch++;\n    }\n\n    return this.events;\n  }\n}\n\nexport { Mock };\n","import React, { useEffect, useMemo } from 'react';\nimport { useDropzone, DropzoneRootProps } from 'react-dropzone';\nimport { isEmpty } from 'lodash';\nimport { saveAs } from 'file-saver';\nimport { readJSONLog } from '../../helper';\nimport { TraceEvent } from '../../types';\nimport { Mock } from '../../mock';\n\nconst baseStyle = {\n  flex: 1,\n  display: 'flex',\n  flexDirection: 'column',\n  alignItems: 'center',\n  padding: '20px',\n  borderWidth: 2,\n  borderRadius: 2,\n  borderColor: '#eeeeee',\n  borderStyle: 'dashed',\n  outline: 'none',\n  transition: 'border .24s ease-in-out',\n};\n\nconst activeStyle = {\n  borderColor: '#2196f3',\n};\n\nconst acceptStyle = {\n  borderColor: '#00e676',\n};\n\nconst rejectStyle = {\n  borderColor: '#ff1744',\n};\n\nfunction saveFile() {\n  const filename = 'events.json';\n  const example: TraceEvent[] = new Mock().mock();\n\n  const blob = new Blob([JSON.stringify(example)], {\n    type: 'application/json',\n  });\n  saveAs(blob, filename);\n}\n\nexport function JSONLogReader({\n  onLoad,\n}: {\n  onLoad: (events: TraceEvent[]) => void;\n}) {\n  const {\n    getRootProps,\n    getInputProps,\n    isDragActive,\n    isDragAccept,\n    isDragReject,\n    acceptedFiles,\n  } = useDropzone({ accept: '.json', multiple: false });\n\n  useEffect(() => {\n    if (!isEmpty(acceptedFiles) && onLoad) {\n      readJSONLog(acceptedFiles[0]).then(onLoad);\n    }\n  }, [acceptedFiles]);\n\n  const style = useMemo(\n    () => ({\n      ...baseStyle,\n      ...(isDragActive ? activeStyle : {}),\n      ...(isDragAccept ? acceptStyle : {}),\n      ...(isDragReject ? rejectStyle : {}),\n    }),\n    [isDragAccept, isDragActive, isDragReject],\n  );\n\n  return (\n    <div className=\"container\">\n      <div {...getRootProps({ style } as DropzoneRootProps)}>\n        <input {...getInputProps()} />\n        <p>\n          Drag a parsed <strong>events.json</strong> here, or click to select\n          file\n        </p>\n      </div>\n      <div>\n        Or try this mock&nbsp;\n        <a onClick={() => saveFile()}>events.json</a>\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\nimport { useStoreActions, useStoreState } from '../store';\nimport { Profile } from './Profile';\nimport { JSONLogReader } from '../component/FileZone';\n\nexport const Guide = () => {\n  const eventLoaded = useStoreState(state => state.tracer.eventLoaded);\n  const loadEvents = useStoreActions(actions => actions.tracer.loadEvents);\n\n  if (eventLoaded) return <Profile />;\n  return <JSONLogReader onLoad={loadEvents} />;\n};\n","import React from 'react';\nimport './App.css';\nimport { store } from './store';\nimport { StoreProvider } from 'easy-peasy';\nimport { Layout } from 'antd';\nimport { AppHeader } from './container/Header';\nimport { Guide } from './container/Guide';\n\nconst { Content } = Layout;\n\nconst App: React.FC = () => {\n  return (\n    <StoreProvider store={store}>\n      <AppHeader />\n      <Content>\n        <Guide />\n      </Content>\n    </StoreProvider>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}